<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <title>JSDoc: Source: unique_sequence.js</title>
    
    <script src="scripts/prettify/prettify.js"> </script>
    <script src="scripts/prettify/lang-css.js"> </script>
    <!--[if lt IE 9]>
      <script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script>
    <![endif]-->
    <link type="text/css" rel="stylesheet" href="styles/prettify-tomorrow.css">
    <link type="text/css" rel="stylesheet" href="styles/jsdoc-default.css">
</head>

<body>

<div id="main">
    
    <h1 class="page-title">Source: unique_sequence.js</h1>
    
    


    
    <section>
        <article>
            <pre class="prettyprint source"><code>var UniqueSequence = CachingSequence.inherit(function(parent) {
  this.parent = parent;
});

UniqueSequence.prototype.each = function(fn) {
  var set = new Set(),
      i = 0;
  this.parent.each(function(e) {
    if (set.add(e)) {
      return fn(e, i++);
    }
  });
};

/**
 * @constructor
 */
function UniqueArrayWrapper(parent) {
  this.parent = parent;
  this.each = getEachForSource(parent.source);
}

UniqueArrayWrapper.prototype = new CachingSequence();

UniqueArrayWrapper.prototype.eachNoCache = function(fn) {
  var source = this.parent.source,
      length = source.length,
      value,
      found,

      // Yes, this is hideous.
      // Trying to get performance first, will refactor next!
      i = -1,
      j,
      k = 0;

  while (++i &lt; length) {
    value = source[i];
    found = false;

    // Scan downwards to look for a dupe.
    j = i - 1;
    while (j >= 0) {
      if (source[j--] === value) {
        found = true;
        break;
      }
    }

    if (!found && fn(source[i], k++) === false) {
      return false;
    }
  }
};

UniqueArrayWrapper.prototype.eachArrayCache = function(fn) {
  // Basically the same implementation as w/ the set, but using an array because
  // it's cheaper for smaller sequences.
  var source = this.parent.source,
      length = source.length,
      cache = [],
      value,
      i = -1,
      j = 0;
  while (++i &lt; length) {
    value = source[i];
    if (!contains(cache, value)) {
      cache.push(value);
      if (fn(value, j++) === false) {
        return false;
      }
    }
  }
};

UniqueArrayWrapper.prototype.eachSetCache = UniqueSequence.prototype.each;

// So, this is kinda shocking.
// Soon I'll write a whole blog post about this; but for now suffice it to say
// that going w/ a no-cache approach is the fastest solution until around 200
// elements, at which point using an array-based cache is still faster than
// using a set-based cache. Not until somewhere around 800 elements does a set-
// based approach start to outpace the others.
function getEachForSource(source) {
  if (source.length &lt; 200) {
    return UniqueArrayWrapper.prototype.eachNoCache;
  } else if (source.length &lt; 800) {
    return UniqueArrayWrapper.prototype.eachArrayCache;
  } else {
    return UniqueSequence.prototype.each;
  }
}
</code></pre>
        </article>
    </section>




</div>

<nav>
    <h2><a href="index.html">Index</a></h2><h3>Classes</h3><ul><li><a href="ArrayWrapper.html">ArrayWrapper</a></li><li><a href="CharIterator.html">CharIterator</a></li><li><a href="FilteringIterator.html">FilteringIterator</a></li><li><a href="Iterator.html">Iterator</a></li><li><a href="MappedArrayWrapper.html">MappedArrayWrapper</a></li><li><a href="ObjectWrapper.html">ObjectWrapper</a></li><li><a href="Sequence.html">Sequence</a></li><li><a href="Set.html">Set</a></li><li><a href="SplitWithRegExpIterator.html">SplitWithRegExpIterator</a></li><li><a href="SplitWithStringIterator.html">SplitWithStringIterator</a></li><li><a href="StringMatchIterator.html">StringMatchIterator</a></li><li><a href="StringWrapper.html">StringWrapper</a></li><li><a href="UniqueArrayWrapper.html">UniqueArrayWrapper</a></li></ul><h3>Global</h3><ul><li><a href="global.html#compare">compare</a></li><li><a href="global.html#createSet">createSet</a></li><li><a href="global.html#recursiveForEach">recursiveForEach</a></li></ul>
</nav>

<br clear="both">

<footer>
    Documentation generated by <a href="https://github.com/jsdoc3/jsdoc">JSDoc 3.2.0-dev</a> on Thu May 23 2013 13:55:45 GMT-0700 (PDT)
</footer>

<script> prettyPrint(); </script>
<script src="scripts/linenumber.js"> </script>
</body>
</html>
